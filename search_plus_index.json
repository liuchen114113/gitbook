{"./":{"url":"./","title":"简介","keywords":"","body":"简介 最近准备面试，刚好梳理下前端的一些知识点，分为html/css/javascript/react/浏览器/算法/原理性知识点等几个部分 Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 13:12:33 "},"HTML语义化.html":{"url":"HTML语义化.html","title":"HTML/CSS基础","keywords":"","body":"HTML语义化 1、什么是语义化 2、有哪些语义化的标签 1、什么是语义化 语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 总结起来就是： 正确的标签做正确的事情 页面内容结构化 无CSS样子时也容易阅读，便于阅读维护和理解 便于浏览器、搜索引擎解析。 利于爬虫标记、利于SEO 2、有哪些语义化的标签 header 元素 header代表“网页”或者“section”的页眉，通常包含h1-h6 元素或者 hgroup, 作为整个页面或者一个内容快的标题。也可以包裹一节的目录部分，一个搜索框，一个nav，或者相关logo。 hgroup 元素 hgroup 元素代表“网页”或“section”的标题，当元素有多个层级时，该元素可以将h1到h6元素放在其内，譬如文章的主标题和副标题组合 footer 元素 footer元素代表“网页”或任意“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。如果footer元素包含了整个节，那么它们就代表附录，索引，提拔，许可协议，标签，类别等一些其他类似信息。 nav 元素 nav 元素代表页面的导航链接区域。用于定义页面的主要导航部分。 HTML语义化 CSS 语义化 article 元素 article 代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。 除了它的内容，article会有一个标题(通常会在header里)，一个footer页脚。 你好，我是这边文章的标题 你好，我是文章的内容 最终解释权归XXX所有 section 元素 section 元素代表文档中的“节”或“段”，“段”可以是指一片文章里按照主题的分段；“节”可以是指一个页面里的分组。section通常还带标题，虽然html5中section会自动给标题h1-h6降级，但是最好手动给他们降级。 section是啥？ 关于section section的介绍 关于其他 关于其他section的介绍 Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 11:34:26 "},"meta标签有什么作用.html":{"url":"meta标签有什么作用.html","title":"meta标签有什么作用","keywords":"","body":"meta标签 1、什么是meta标签 1、什么是meta标签 该标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 基本属性 属性 值 描述 keywords author / description / keywords / generator / revised / others 把 content 属性关联到一个名称。 content some text 定义与http-equiv或name属性相关的元信息 http-equiv content-type / expire / refresh / set-cookie 把content属性关联到HTTP头部。 举例： Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 11:34:26 "},"script标签及其加载顺序的区别.html":{"url":"script标签及其加载顺序的区别.html","title":"script标签及其加载顺序的区别","keywords":"","body":"script标签 script标签的加载顺序 defer属性 async属性 1、script标签的加载顺序 浏览器保证JS执行顺序和书写顺序/依赖顺序一致，尽管它们的加载顺序不是一致的（加载为并行加载并缓存） 2、defer属性 只适用于外部脚本文件。脚本会立即下载，但是会延迟到整个页面全部加载完毕之后再运行。defer多个脚本是按照顺序执行的，如果有依赖关系，需要特别注意脚本顺序。 3、async属性 只适用于外部脚本文件。脚本会立即下载，但是下载完毕之后立即执行，运行的同时并不阻止浏览器去解析下面的内容。使用async主要是脚本下载时并不影响页面的渲染。多个async脚本之间不能保证运行顺序 Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 11:34:26 "},"src属性和href属性的区别.html":{"url":"src属性和href属性的区别.html","title":"src属性和href属性的区别","keywords":"","body":"src属性和href属性 href（hypertext reference）： 表示超文本引用，用来建立当前元素和文档间的链接。常用的有link，a 当CSS使用href引用，浏览器会识别该文档问CSS，并行下载，不会停止对当前文档的加载。 src（source）： src指向的内容会嵌入到文档中当前标签的位置,常用的有img, script, iframe 浏览器解析到该元素时会停止对文档的渲染，直到该资源加载完成。这也是将script放底部而不是头部的原因。 Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 11:34:26 "},"盒模型.html":{"url":"盒模型.html","title":"盒模型","keywords":"","body":"盒模型 1、基本概念 2、content-box 3、border-box 1、基本概念 盒模型(box model)是CSS中的一个重要概念，它是元素大小的呈现方式。标准模型 box-sizing:content-box IE模型 box-sizing:border-box 2、content-box 布局所占宽度Width： Width = width + padding-left + padding-right + border-left + border-right 3、border-box 布局所占宽度Width： Width = width(包含padding-left + padding-right + border-left + border-right) Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-03-01 12:16:40 "},"CSS普通流（文档流）.html":{"url":"CSS普通流（文档流）.html","title":"CSS普通流（文档流）","keywords":"","body":"CSS普通流（文档流） 首先明确一点的是，W3C规范中没有document flow这个概念，只有normal-flow, 文档流的叫法主要还是多数中文译者的翻译方式问题。 1、什么是普通流 2、调节普通流元素位置 3、脱离文档流 1、什么是普通流 什么是普通流？简单说就是元素按照其在 HTML 中的位置顺序决定排布的过程。并且这种过程遵循标准的描述。浏览器在渲染代码的时候是从左往右、从上到下开始渲染，元素也是从左往右、从上往下的流式排列。也就是没有被其他排版浮动和定位相关的CSS属性干扰的就叫标准流。 2、调节普通流元素位置 一般使用margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“距离”。只要不是float和绝对定位方式布局的，都在普通流里面。 2、脱离文档流 脱离文档流就是将元素从普通的布局排版中拿走。那么什么时候会使元素脱离文档流呢？ 浮动 定位（绝对定位和固定定位） Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 12:29:34 "},"CSS布局.html":{"url":"CSS布局.html","title":"CSS布局","keywords":"","body":"Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 11:34:26 "},"CSS选择器.html":{"url":"CSS选择器.html","title":"CSS选择器","keywords":"","body":"Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 11:34:26 "},"CSS动画.html":{"url":"CSS动画.html","title":"CSS动画","keywords":"","body":"Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 11:34:26 "},"作用域和作用域链.html":{"url":"作用域和作用域链.html","title":"JavaScript","keywords":"","body":"作用域和作用域链 1、作用域(Scope)) 2、作用域链 1、作用域(Scope) 1.什么是作用域 作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。可能这两句话并不好理解，我们先来看个例子： function outFun2() { var inVariable = \"内层变量2\"; } outFun2();//要先执行这个函数，否则根本不知道里面是啥 console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined 复制代码 从上面的例子可以体会到作用域的概念，变量inVariable在全局作用域没有声明，所以在全局作用域下取值会报错。我们可以这样理解：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6的到来，为我们提供了‘块级作用域’,可通过新增命令let和const来体现。 2.全局作用域和函数作用域 在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： 最外层函数 和在最外层函数外面定义的变量拥有全局作用域 var outVariable = \"我是最外层变量\"; //最外层变量 function outFun() { //最外层函数 var inVariable = \"内层变量\"; function innerFun() { //内层函数 console.log(inVariable); } innerFun(); } console.log(outVariable); //我是最外层变量 outFun(); //内层变量 console.log(inVariable); //inVariable is not defined innerFun(); //innerFun is not defined 复制代码 所有末定义直接赋值的变量自动声明为拥有全局作用域 function outFun2() { variable = \"未定义直接赋值的变量\"; var inVariable2 = \"内层变量2\"; } outFun2();//要先执行这个函数，否则根本不知道里面是啥 console.log(variable); //未定义直接赋值的变量 console.log(inVariable2); //inVariable2 is not defined 复制代码 所有window对象的属性拥有全局作用域 一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。 全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。 // 张三写的代码中 var data = {a: 100} // 李四写的代码中 var data = {x: true} 复制代码 这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在(function(){....})()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。 函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。 function doSomething(){ var blogName=\"浪里行舟\"; function innerSay(){ alert(blogName); } innerSay(); } alert(blogName); //脚本错误 innerSay(); //脚本错误 复制代码 作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。我们看个例子，用泡泡来比喻作用域可能好理解一点： 最后输出的结果为 2, 4, 12 泡泡1是全局作用域，有标识符foo； 泡泡2是作用域foo，有标识符a,bar,b； 泡泡3是作用域bar，仅有标识符c。 值得注意的是：块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域。在块语句中定义的变量将保留在它们已经存在的作用域中。 if (true) { // 'if' 条件语句块不会创建一个新的作用域 var name = 'Hammad'; // name 依然在全局作用域中 } console.log(name); // logs 'Hammad' 复制代码 JS 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致 bug 。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。 3.块级作用域 块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建： 在一个函数内部 在一个代码块（由一对花括号包裹）内部 let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点： 声明变量不会提升到代码块顶部 let/const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。 function getValue(condition) { if (condition) { let value = \"blue\"; return value; } else { // value 在此处不可用 return null; } // value 在此处不可用 } 复制代码 禁止重复声明 如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误。例如： var count = 30; let count = 40; // Uncaught SyntaxError: Identifier 'count' has already been declared 复制代码 在本例中， count 变量被声明了两次：一次使用 var ，另一次使用 let 。因为 let 不能在同一作用域内重复声明一个已有标识符，此处的 let 声明就会抛出错误。但如果在嵌套的作用域内使用 let 声明一个同名的新变量，则不会抛出错误。 var count = 30; // 不会抛出错误 if (condition) { let count = 40; // 其他代码 } 复制代码 循环中的绑定块作用域的妙用 开发者可能最希望实现for循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，例如： for (let i = 0; i 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 var a = []; for (var i = 0; i 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 var a = []; for (let i = 0; i 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 for (let i = 0; i 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 2、作用域链 1.什么是自由变量 首先认识一下什么叫做 自由变量 。如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。 var a = 100 function fn() { var b = 200 console.log(a) // 这里的a在这里就是一个自由变量 console.log(b) } fn() 复制代码 2.什么是作用域链 如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。 var a = 100 function F1() { var b = 200 function F2() { var c = 300 console.log(a) // 自由变量，顺作用域链向父作用域找 console.log(b) // 自由变量，顺作用域链向父作用域找 console.log(c) // 本作用域的变量 } F2() } F1() 复制代码 3.关于自由变量的取值 关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。 var x = 10 function fn() { console.log(x) } function show(f) { var x = 20 (function() { f() //10，而不是20 })() } show(fn) 复制代码 在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取，无论fn函数将在哪里调用。 所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切:要到创建这个函数的那个域”。 作用域中取值,这里强调的是“创建”，而不是“调用”，切记切记——其实这就是所谓的\"静态作用域\" var a = 10 function fn() { var b = 20 function bar() { console.log(a + b) //30 } return bar } var x = fn(), b = 200 x() //bar() 复制代码 fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了,所以最后的结果是30 作用域与执行上下文 许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。 我们知道JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样： 解释阶段： 词法分析 语法分析 作用域规则确定 执行阶段： 创建执行上下文 执行函数代码 垃圾回收 JavaScript解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。 作用域和执行上下文之间最大的区别是： 执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。 一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。 Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 12:52:24 "},"闭包.html":{"url":"闭包.html","title":"闭包","keywords":"","body":"Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 13:04:58 "},"原型.html":{"url":"原型.html","title":"原型","keywords":"","body":"Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 13:05:09 "},"继承.html":{"url":"继承.html","title":"继承","keywords":"","body":"Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 13:05:17 "},"垃圾回收机制.html":{"url":"垃圾回收机制.html","title":"垃圾回收机制","keywords":"","body":"Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 13:05:38 "},"浏览器运行机制.html":{"url":"浏览器运行机制.html","title":"浏览器","keywords":"","body":"Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 13:13:04 "},"宏任务和微任务.html":{"url":"宏任务和微任务.html","title":"宏任务和微任务","keywords":"","body":"Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 13:05:29 "},"跨域.html":{"url":"跨域.html","title":"跨域","keywords":"","body":"Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-02-29 13:15:26 "},"this指向的改变.html":{"url":"this指向的改变.html","title":"原理性知识实现方案","keywords":"","body":"this指向的改变 1、call 2、apply 3、bind 1、call Function.prototype.call = function (target, ...args) { var context = target || window context.fn = this var result = context.fn(...args) delete context.fn return result } 2、apply Function.prototype.apply = function (target, args) { var context = target context.fn = this let result = args && args.length ? context.fn(...args) : context.fn() delete context.fn return result } 3、bind Function.prototype.bind = function (target, args) { let _this = this return function () { let context = target context.fn = _this let res = args && args.length ? context.fn(...args) : context.fn() delete context.fn return res } } Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-03-01 12:33:58 "},"instanceof的实现.html":{"url":"instanceof的实现.html","title":"instanceof的实现","keywords":"","body":"instanceof的实现 function myInstanceof(left, right) { while (left !== null) { if (left.__proto__ === right.prototype) { return true } else { left = left.__proto__ } } return false } Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-03-01 12:36:21 "},"深拷贝和浅拷贝的实现.html":{"url":"深拷贝和浅拷贝的实现.html","title":"深拷贝和浅拷贝的实现","keywords":"","body":"js 深拷贝 vs 浅拷贝 原文作者 堆和栈的区别 其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同。 堆和栈都是内存中划分出来用来存储的区域。 栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。 ECMAScript 的数据类型 在将深拷贝和浅拷贝之前，我们先来重新回顾一下 ECMAScript 中的数据类型。主要分为 基本数据类型（undefined，boolean，number，string，null） 基本数据类型主要是：undefined，boolean，number，string，null。 基本数据类型存放在栈中 存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。 基本数据类型值不可变 javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此 —— 改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来假改字符串中的字符。实际上，javascript 是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。 基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如： var str = \"abc\"; console.log(str[1]=\"f\"); // f console.log(str); // abc 我们通常情况下都是对一个变量重新赋值，而不是改变基本数据类型的值。就如上述引用所说的那样，在 js 中没有方法是可以改变布尔值和数字的。倒是有很多操作字符串的方法，但是这些方法都是返回一个新的字符串，并没有改变其原有的数据。 所以，记住这一点：基本数据类型值不可变。 基本类型的比较是值的比较 基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如： var a = 1; var b = 1; console.log(a === b);//true 比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如： var a = 1; var b = true; console.log(a == b);//true 引用类型 引用类型存放在堆中 引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配。 引用类型值可变 引用类型是可以直接改变其值的，例如： var a = [1,2,3]; a[1] = 5; console.log(a[1]); // 5 引用类型的比较是引用的比较 所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： var a = [1,2,3]; var b = [1,2,3]; console.log(a === b); // false 虽然变量 a 和变量 b 都是表示一个内容为 1，2，3 的数组，但是其在内存中的位置不一样，也就是说变量 a 和变量 b 指向的不是同一个对象，所以他们是不相等的。 引用类型在内存中的存储 （懒癌晚期，不想自己画图了，直接盗图） 传值与传址 了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。 在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如： var a = 10; var b = a; a++ ; console.log(a); // 11 console.log(b); // 10 基本数据类型的赋值 所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。 但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如： var a = {}; // a保存了一个空对象的实例 var b = a; // a和b都指向了这个空对象 a.name = 'jozo'; console.log(a.name); // 'jozo' console.log(b.name); // 'jozo' b.age = 22; console.log(b.age);// 22 console.log(a.age);// 22 console.log(a == b);// true 引用类型的赋值 浅拷贝 在深入了解之前，我认为上面的赋值就是浅拷贝，哇哈哈，真的是图样图森破。上面那个应该只能算是“引用”，并不算是真正的浅拷贝。 一下部分参照知乎中的提问： javascript中的深拷贝和浅拷贝 赋值（=）和浅拷贝的区别 那么赋值和浅拷贝有什么区别呢，我们看下面这个例子： var obj1 = { 'name' : 'zhangsan', 'age' : '18', 'language' : [1,[2,3],[4,5]], }; var obj2 = obj1; var obj3 = shallowCopy(obj1); function shallowCopy(src) { var dst = {}; for (var prop in src) { if (src.hasOwnProperty(prop)) { dst[prop] = src[prop]; } } return dst; } obj2.name = \"lisi\"; obj3.age = \"20\"; obj2.language[1] = [\"二\",\"三\"]; obj3.language[2] = [\"四\",\"五\"]; console.log(obj1); //obj1 = { // 'name' : 'lisi', // 'age' : '18', // 'language' : [1,[\"二\",\"三\"],[\"四\",\"五\"]], //}; console.log(obj2); //obj2 = { // 'name' : 'lisi', // 'age' : '18', // 'language' : [1,[\"二\",\"三\"],[\"四\",\"五\"]], //}; console.log(obj3); //obj3 = { // 'name' : 'zhangsan', // 'age' : '20', // 'language' : [1,[\"二\",\"三\"],[\"四\",\"五\"]], //}; 先定义个一个原始的对象 obj1，然后使用赋值得到第二个对象 obj2，然后通过浅拷贝，将 obj1 里面的属性都赋值到 obj3 中。也就是说： obj1：原始数据 obj2：赋值操作得到 obj3：浅拷贝得到 然后我们改变 obj2 的 name 属性和 obj3 的 name 属性，可以看到，改变赋值得到的对象 obj2 同时也会改变原始值 obj1，而改变浅拷贝得到的的 obj3 则不会改变原始对象 obj1。这就可以说明赋值得到的对象 obj2 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 obj3 则是重新创建了新对象。 然而，我们接下来来看一下改变引用类型会是什么情况呢，我又改变了赋值得到的对象 obj2 和浅拷贝得到的 obj3 中的 language 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）。结果见输出，可以看出来，无论是修改赋值得到的对象 obj2 和浅拷贝得到的 obj3 都会改变原始数据。 这是因为浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 obj3 中的引用类型时，会使原始数据得到改变。 深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象， 浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象 -- 和原数据是否指向同一对象 第一层数据为基本数据类型 原数据中包含子对象 赋值 是 改变会使原数据一同改变 改变会使原数据一同改变 浅拷贝 否 改变不会使原数据一同改变 改变会使原数据一同改变 深拷贝 否 改变不会使原数据一同改变 改变不会使原数据一同改变 深拷贝 看了这么半天，你也应该清楚什么是深拷贝了吧，如果还不清楚，我就剖腹自尽(ಥ_ಥ) 深拷贝是对对象以及对象的所有子对象进行拷贝。 那么问题来了，怎么进行深拷贝呢？ 思路就是递归调用刚刚的浅拷贝，把所有属于对象的属性类型都遍历赋给另一个对象即可。我们直接来看一下 Zepto 中深拷贝的代码： // 内部方法：用户合并一个或多个对象到第一个对象 // 参数： // target 目标对象 对象都合并到target里 // source 合并对象 // deep 是否执行深度合并 function extend(target, source, deep) { for (key in source) if (deep && (isPlainObject(source[key]) || isArray(source[key]))) { // source[key] 是对象，而 target[key] 不是对象， 则 target[key] = {} 初始化一下，否则递归会出错的 if (isPlainObject(source[key]) && !isPlainObject(target[key])) target[key] = {} // source[key] 是数组，而 target[key] 不是数组，则 target[key] = [] 初始化一下，否则递归会出错的 if (isArray(source[key]) && !isArray(target[key])) target[key] = [] // 执行递归 extend(target[key], source[key], deep) } // 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了 else if (source[key] !== undefined) target[key] = source[key] } // Copy all but undefined properties from one or more // objects to the `target` object. $.extend = function(target){ var deep, args = slice.call(arguments, 1); //第一个参数为boolean值时，表示是否深度合并 if (typeof target == 'boolean') { deep = target; //target取第二个参数 target = args.shift() } // 遍历后面的参数，都合并到target上 args.forEach(function(arg){ extend(target, arg, deep) }) return target } 在 Zepto 中的 $.extend 方法判断的第一个参数传入的是一个布尔值，判断是否进行深拷贝。 在 $.extend 方法内部，只有一个形参 target，这个设计你真的很巧妙。 因为形参只有一个，所以 target 就是传入的第一个参数的值，并在函数内部设置一个变量 args 来接收去除第一个参数的其余参数，如果该值是一个布尔类型的值的话，说明要启用深拷贝，就将 deep 设置为 true，并将 target 赋值为 args 的第一个值（也就是真正的 target）。如果该值不是一个布尔类型的话，那么传入的第一个值仍为 target 不需要进行处理，只需要遍历使用 extend 方法就可以。 这里有点绕，但是真的设计的很精妙，建议自己打断点试一下，会有意外收获（玩转 js 的大神请忽略）。 而在 extend 的内部，是拷贝的过程。 Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-03-01 12:53:33 "},"节流和防抖.html":{"url":"节流和防抖.html","title":"节流和防抖","keywords":"","body":"节流和防抖 1、节流 2、防抖 1、节流 function throttle(func, wait) { if(typeof func !== 'function') { throw new TypeError('need a function') } var previous = 0 return function () { var now = +new Date() if (now - previous > wait) { func.apply(this, arguments) previous = now } } } 2、防抖 function debounce(fn, wait) { if (typeof func !== 'function') { throw new TypeError('need a function') } let timer = null return function (...args) { timer && clearTimeout(timer) timer = setTimeout(() => { func(...args) }, wait) } } Copyright &chen 2020 all right reserved，powered by Gitbook修订时间： 2020-03-01 13:59:22 "}}